i    = index)
# set up for parallel processing ----------------------------------------------
numCores <- detectCores() - 2 # leave one core to run the computer
cl <- makeCluster(numCores) # make a cluster running R in parallel
# load the testing data on each cluster ---------------------------------------
clusterEvalQ(cl = cl, {
library(astroBayes)
library(tidyverse)
library(astrochron)
# load required data
cyclostrat <- read.csv(file = './data/CIP2/cyclostrat_data.csv') %>%
linterp(dt = 0.025,
genplot = FALSE)
tuning_frequency  <- read.csv('./data/CIP2/tuning_frequency.csv')
true_data         <- read.csv(file = './data/CIP2/true_age.csv')
segment_edges <-
data.frame(position = c(0, 3, 5.75, 10),
thickness = c(0, 0.5, 0.5, 0),
hiatus_boundary = c(FALSE, FALSE, TRUE, FALSE),
sed_min = c(7.5, 7.5, 10, 5),
sed_max = c(15, 17.5, 20, 20))
}
)
##-----------------------------------------------------------------------------
## make a function for parallel processing
age_model <- function(i,
size) {
# make sure the hiatus is bracketed
good <- FALSE
bad = TRUE
repeat{
# generate some random geochronology --------------------
index <- sample(seq_along(true_data$position), size = size)
tmp   <- true_data[index, ]
id    <- paste0('sample_', index)
# check to make sure the hiatus is bracketed
# keep dates out of the hiatus
bad <- any(between(tmp$position, 5.24, 6.26))
good = any(between(tmp$position, 0, 5.24)) &
any(between(tmp$position, 6.26, 10))
if(good == TRUE) {
if(bad == FALSE) {
break()
}
}
}
# make some random dates --------------------------------
geochron_data <- data.frame(
id = id,
age = tmp$age,
age_sd =  tmp$age * 0.015,
position = tmp$position,
thickness = 0)
# run the model -----------------------------------------
model <- astro_bayes_model(
geochron_data = geochron_data,
cyclostrat_data = cyclostrat,
tuning_frequency = tuning_frequency,
segment_edges = segment_edges,
iterations = 10000,
burn = 1000,
method = 'malinverno')
# prep the model outputs --------------------------------
f <- approxfun(x = true_data$position,
y = true_data$age)
true_age <- f(model$CI$position)
# write the model CI to a csv --------------------------
model_folder <- paste0('./results/random_age_validation/CIP2_',
size,
'_ages/')
model_name   <- paste0(size,'_age_model_',
i,
'.rds')
model |>
write_rds(file = paste0(model_folder, model_name))
rm(model)
}
# run R in parallel ------------------------------------------------------------
start <- Sys.time()
clusterMap(cl = cl,
fun = age_model,
size = tests$size,
i = tests$i)
# load required libraries -----------------------------------------------------
library(tidyverse)
theme_set(theme_minimal())
# load all the data -----------------------------------------------------------
file_list <- list.files('./results/random_age_validation/CIP2_2_ages/',
full.names = TRUE,
pattern = '*.rds')
storage <- data.frame(duration = vector(length = length(file_list)),
delta    = vector(length = length(file_list)))
for(i in seq_along(file_list)) {
model <- read_rds(file_list[i])
hiatus_position <- model$segment_edges$position[model$segment_edges$hiatus]
storage$duration[i] <- model$hiatus_durations |> median()
storage$delta[i] <- (model$geochron_data$position - hiatus_position) |>
abs() |>
min()
rm(model)
}
storage |>
ggplot(mapping = aes(x = delta,
y = duration)) +
geom_point() +
# ylim(0.15, 0.25) +
ggtitle('4 ages') +
geom_hline(yintercept = 0.205)
library(astroBayes)
read_rds(file = file_list[i]) |>
plot(type = 'age_depth(')
read_rds(file = file_list[i]) |>
plot(type = 'age_depth')
# load required libraries -----------------------------------------------------
library(tidyverse)
library(astroBayes)
theme_set(theme_minimal())
# load all the data -----------------------------------------------------------
file_list <- list.files('./results/random_age_validation/CIP2_2_ages/',
full.names = TRUE,
pattern = '*.rds')
storage <- data.frame(duration = vector(length = length(file_list)),
delta    = vector(length = length(file_list)))
for(i in seq_along(file_list)) {
model <- read_rds(file_list[i])
hiatus_position <- model$segment_edges$position[model$segment_edges$hiatus]
storage$duration[i] <- model$hiatus_durations |> median()
storage$delta[i] <- (model$geochron_data$position - hiatus_position) |>
abs() |>
min()
read_rds(file = file_list[i]) |>
plot(type = 'age_depth')
rm(model)
}
for(i in 1:18){
read_rds(file = file_list[i]) |>
plot(type = 'age_depth')
}
read_rds(file = file_list[i]) |>
plot(type = 'age_depth') |>
view()
for(i in 1:18){
read_rds(file = file_list[i]) |>
plot(type = 'age_depth') |>
print()
}
storage |>
ggplot(mapping = aes(x = delta,
y = duration)) +
geom_point() +
# ylim(0.15, 0.25) +
ggtitle('4 ages') +
geom_hline(yintercept = 0.205)
# load required libraries -----------------------------------------------------
library(parallel)
library(tidyverse)
# set up the models to test ---------------------------------------------------
iterations <- 1000 # test each set of parameters 1000 times
size     <- rep(c(2, 4, 6, 8), each = iterations) # vary between 2 - 8 ages
index    <- rep(1:iterations, times = length(size) / iterations) # add iterations
# put it in a data frame
tests    <- data.frame(size = size,
i    = index)
# set up for parallel processing ----------------------------------------------
numCores <- detectCores() - 2 # leave one core to run the computer
cl <- makeCluster(numCores) # make a cluster running R in parallel
# load the testing data on each cluster ---------------------------------------
clusterEvalQ(cl = cl, {
library(astroBayes)
library(tidyverse)
library(astrochron)
# load required data
cyclostrat <- read.csv(file = './data/CIP2/cyclostrat_data.csv') %>%
linterp(dt = 0.025,
genplot = FALSE)
tuning_frequency  <- read.csv('./data/CIP2/tuning_frequency.csv')
true_data         <- read.csv(file = './data/CIP2/true_age.csv')
segment_edges <-
data.frame(position = c(0, 3, 5.75, 10),
thickness = c(0, 0.5, 0.5, 0),
hiatus_boundary = c(FALSE, FALSE, TRUE, FALSE),
sed_min = c(7.5, 7.5, 10, 5),
sed_max = c(15, 17.5, 20, 20))
}
)
##-----------------------------------------------------------------------------
## make a function for parallel processing
age_model <- function(i,
size) {
# make sure the hiatus is bracketed
good <- FALSE
bad = TRUE
repeat{
# generate some random geochronology --------------------
index <- sample(seq_along(true_data$position), size = size)
tmp   <- true_data[index, ]
id    <- paste0('sample_', index)
# check to make sure the hiatus is bracketed
# keep dates out of the hiatus
bad <- any(between(tmp$position, 5.24, 6.26))
good = any(between(tmp$position, 0, 5.24)) &
any(between(tmp$position, 6.26, 10))
if(good == TRUE) {
if(bad == FALSE) {
break()
}
}
}
# make some random dates --------------------------------
geochron_data <- data.frame(
id = id,
age = tmp$age,
age_sd =  tmp$age * 0.015,
position = tmp$position,
thickness = 0)
# run the model -----------------------------------------
model <- astro_bayes_model(
geochron_data = geochron_data,
cyclostrat_data = cyclostrat,
tuning_frequency = tuning_frequency,
segment_edges = segment_edges,
iterations = 10000,
burn = 1000,
method = 'malinverno')
# prep the model outputs --------------------------------
f <- approxfun(x = true_data$position,
y = true_data$age)
true_age <- f(model$CI$position)
# write the model CI to a csv --------------------------
model_folder <- paste0('./results/random_age_validation/CIP2_',
size,
'_ages/')
model_name   <- paste0(size,'_age_model_',
i,
'.rds')
model |>
write_rds(file = paste0(model_folder, model_name))
rm(model)
}
# run R in parallel ------------------------------------------------------------
start <- Sys.time()
clusterMap(cl = cl,
fun = age_model,
size = tests$size,
i = tests$i)
stopCluster(cl)
end <- Sys.time()
print(end - start)
# load required libraries -----------------------------------------------------
library(tidyverse)
library(astroBayes)
theme_set(theme_minimal())
# load all the data -----------------------------------------------------------
file_list <- list.files('./results/random_age_validation/CIP2_2_ages/',
full.names = TRUE,
pattern = '*.rds')
storage <- data.frame(duration = vector(length = length(file_list)),
delta    = vector(length = length(file_list)))
for(i in seq_along(file_list)) {
model <- read_rds(file_list[i])
hiatus_position <- model$segment_edges$position[model$segment_edges$hiatus]
storage$duration[i] <- model$hiatus_durations |> median()
storage$delta[i] <- (model$geochron_data$position - hiatus_position) |>
abs() |>
min()
rm(model)
}
storage |>
ggplot(mapping = aes(x = delta,
y = duration)) +
geom_point() +
# ylim(0.15, 0.25) +
ggtitle('4 ages') +
geom_hline(yintercept = 0.205)
for(i in 1:18){
read_rds(file = file_list[i]) |>
plot(type = 'age_depth') |>
print()
}
storage |>
ggplot(mapping = aes(x = delta,
y = duration)) +
geom_point() +
# ylim(0.15, 0.25) +
ggtitle('4 ages') +
geom_hline(yintercept = 0.205)
# load all the data -----------------------------------------------------------
file_list <- list.files('./results/random_age_validation/CIP2_2_ages/',
full.names = TRUE,
pattern = '*.rds')
storage <- data.frame(median  = vector(length = length(file_list)),
CI_2.5  = vector(length = length(file_list)),
CI_97.5 = vector(length = length(file_list)),
delta   = vector(length = length(file_list)))
for(i in seq_along(file_list)) {
model <- read_rds(file_list[i])
hiatus_position <- model$segment_edges$position[model$segment_edges$hiatus]
storage$median[i] <- model$hiatus_durations |> median()
storage$median[i] <- model$hiatus_durations |> quantile(prob = 0.025)
storage$median[i] <- model$hiatus_durations |> quantile(prob = 0.975)
storage$delta[i] <- (model$geochron_data$position - hiatus_position) |>
abs() |>
min()
rm(model)
}
storage |>
ggplot(mapping = aes(x = delta,
y = median,
ymin = CI_2.5,
ymax = CI_97.5)) +
geom_pointrange() +
ylim(0.1, 0.3) +
ggtitle('4 ages') +
geom_hline(yintercept = 0.205)
storage |>
ggplot(mapping = aes(x = delta,
y = median,
ymin = CI_2.5,
ymax = CI_97.5)) +
# geom_pointrange() +
ylim(0.1, 0.3) +
ggtitle('4 ages') +
geom_hline(yintercept = 0.205)
storage$CI_97.5[i] <- model$hiatus_durations |> quantile(prob = 0.975)
storage$delta[i] <- (model$geochron_data$position - hiatus_position) |>
abs() |>
min()
for(i in seq_along(file_list)) {
model <- read_rds(file_list[i])
hiatus_position <- model$segment_edges$position[model$segment_edges$hiatus]
storage$median[i] <- model$hiatus_durations |> median()
storage$CI_2.5[i] <- model$hiatus_durations |> quantile(prob = 0.025)
storage$CI_97.5[i] <- model$hiatus_durations |> quantile(prob = 0.975)
storage$delta[i] <- (model$geochron_data$position - hiatus_position) |>
abs() |>
min()
rm(model)
}
storage |>
ggplot(mapping = aes(x = delta,
y = median,
ymin = CI_2.5,
ymax = CI_97.5)) +
geom_pointrange() +
ylim(0.1, 0.3) +
ggtitle('4 ages') +
geom_hline(yintercept = 0.205)
storage |>
ggplot(mapping = aes(x = delta,
y = median,
ymin = CI_2.5,
ymax = CI_97.5)) +
geom_pointrange() +
# ylim(0.1, 0.3) +
ggtitle('4 ages') +
geom_hline(yintercept = 0.205)
storage |>
ggplot(mapping = aes(x = delta,
y = median,
ymin = CI_2.5,
ymax = CI_97.5)) +
geom_pointrange(alpha = 0.5) +
# ylim(0.1, 0.3) +
ggtitle('4 ages') +
geom_hline(yintercept = 0.205)
storage |>
ggplot(mapping = aes(x = delta,
y = median,
ymin = CI_2.5,
ymax = CI_97.5)) +
geom_pointrange(alpha = 0.1) +
# ylim(0.1, 0.3) +
ggtitle('4 ages') +
geom_hline(yintercept = 0.205)
# load required libraries -----------------------------------------------------
library(tidyverse)
library(astroBayes)
theme_set(theme_minimal())
# load all the data -----------------------------------------------------------
file_list <- list.files('./results/random_age_validation/CIP2_8_ages/',
full.names = TRUE,
pattern = '*.rds')
storage <- data.frame(median  = vector(length = length(file_list)),
CI_2.5  = vector(length = length(file_list)),
CI_97.5 = vector(length = length(file_list)),
delta   = vector(length = length(file_list)))
for(i in seq_along(file_list)) {
model <- read_rds(file_list[i])
hiatus_position <- model$segment_edges$position[model$segment_edges$hiatus]
storage$median[i] <- model$hiatus_durations |> median()
storage$CI_2.5[i] <- model$hiatus_durations |> quantile(prob = 0.025)
storage$CI_97.5[i] <- model$hiatus_durations |> quantile(prob = 0.975)
storage$delta[i] <- (model$geochron_data$position - hiatus_position) |>
abs() |>
min()
rm(model)
}
storage |>
ggplot(mapping = aes(x = delta,
y = median,
ymin = CI_2.5,
ymax = CI_97.5)) +
geom_pointrange(alpha = 0.1) +
# ylim(0.1, 0.3) +
ggtitle('8 ages') +
geom_hline(yintercept = 0.205)
# load required libraries -----------------------------------------------------
library(tidyverse)
library(astroBayes)
theme_set(theme_minimal())
# load all the data -----------------------------------------------------------
file_list <- list.files('./results/random_age_validation/CIP2_8_ages/',
full.names = TRUE,
pattern = '*.rds')
storage <- data.frame(median  = vector(length = length(file_list)),
CI_2.5  = vector(length = length(file_list)),
CI_97.5 = vector(length = length(file_list)),
delta   = vector(length = length(file_list)))
for(i in seq_along(file_list)) {
model <- read_rds(file_list[i])
hiatus_position <- model$segment_edges$position[model$segment_edges$hiatus]
storage$median[i] <- model$hiatus_durations |> median()
storage$CI_2.5[i] <- model$hiatus_durations |> quantile(prob = 0.025)
storage$CI_97.5[i] <- model$hiatus_durations |> quantile(prob = 0.975)
storage$delta[i] <- (model$geochron_data$position - hiatus_position) |>
abs() |>
min()
rm(model)
}
# load required libraries -----------------------------------------------------
library(tidyverse)
library(astroBayes)
theme_set(theme_minimal())
# load all the data -----------------------------------------------------------
file_list <- list.files('./results/random_age_validation/CIP2_8_ages/',
full.names = TRUE,
pattern = '*.rds')
storage <- data.frame(median  = vector(length = length(file_list)),
CI_2.5  = vector(length = length(file_list)),
CI_97.5 = vector(length = length(file_list)),
delta   = vector(length = length(file_list)))
for(i in seq_along(file_list)) {
model <- read_rds(file_list[i])
hiatus_position <- model$segment_edges$position[model$segment_edges$hiatus]
storage$median[i] <- model$hiatus_durations |> median()
storage$CI_2.5[i] <- model$hiatus_durations |> quantile(prob = 0.025)
storage$CI_97.5[i] <- model$hiatus_durations |> quantile(prob = 0.975)
storage$delta[i] <- (model$geochron_data$position - hiatus_position) |>
abs() |>
min()
rm(model)
}
storage |>
ggplot(mapping = aes(x = delta,
y = median,
ymin = CI_2.5,
ymax = CI_97.5)) +
geom_pointrange(alpha = 0.1) +
# ylim(0.1, 0.3) +
ggtitle('8 ages') +
geom_hline(yintercept = 0.205)
storage |>
ggplot(mapping = aes(x = delta,
y = median,
ymin = CI_2.5,
ymax = CI_97.5)) +
geom_pointrange(alpha = 0.1) +
# ylim(0.1, 0.3) +
ggtitle('8 ages') +
geom_hline(yintercept = 0.405/2)
storage |>
ggplot(mapping = aes(x = delta,
y = median,
ymin = CI_2.5,
ymax = CI_97.5)) +
geom_pointrange(alpha = 0.1) +
# ylim(0.1, 0.3) +
ggtitle('8 ages') +
geom_hline(yintercept = 0.405/2,
color = 'red',
linetype = 'dashed')
storage |>
ggplot(mapping = aes(x = delta,
y = median,
ymin = CI_2.5,
ymax = CI_97.5)) +
geom_pointrange(alpha = 0.1) +
ylim(0, 0.405) +
ggtitle('8 ages') +
geom_hline(yintercept = 0.405/2,
color = 'red',
linetype = 'dashed')
storage |>
ggplot(mapping = aes(x = delta,
y = median,
ymin = CI_2.5,
ymax = CI_97.5)) +
geom_pointrange(alpha = 0.1) +
ylim(0, 0.4) +
ggtitle('8 ages') +
geom_hline(yintercept = 0.405/2,
color = 'red',
linetype = 'dashed')
View(storage)
read_rds(file = file_list[737]) |>
plot(type = 'age_depth')
read_rds(file = file_list[639]) |>
plot(type = 'age_depth')
read_rds(file = file_list[464]) |>
plot(type = 'age_depth')
read_rds(file = file_list[100]) |>
plot(type = 'age_depth')
